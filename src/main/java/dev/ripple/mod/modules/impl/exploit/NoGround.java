package dev.ripple.mod.modules.impl.exploit;

import dev.ripple.api.events.eventbus.EventHandler;
import dev.ripple.api.events.impl.DeathEvent;
import dev.ripple.api.events.impl.MoveEvent;
import dev.ripple.api.events.impl.TickEvent;
import dev.ripple.api.utils.entity.PauseUtil;
import dev.ripple.api.utils.entity.EntityUtil;
import dev.ripple.api.utils.entity.InventoryUtil;
import dev.ripple.api.utils.math.Timer;
import dev.ripple.api.utils.world.BlockUtil;
import dev.ripple.core.impl.CommandManager;
import dev.ripple.mod.modules.Module;
import dev.ripple.mod.modules.impl.client.AntiCheat;
import dev.ripple.mod.modules.impl.movement.FakeFly;
import dev.ripple.mod.modules.impl.player.Freecam;
import dev.ripple.mod.modules.settings.impl.BooleanSetting;
import dev.ripple.mod.modules.settings.impl.EnumSetting;
import dev.ripple.mod.modules.settings.impl.SliderSetting;
import net.minecraft.entity.Entity;
import net.minecraft.entity.decoration.EndCrystalEntity;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.PlayerInteractEntityC2SPacket;
import net.minecraft.util.Hand;
import net.minecraft.util.math.BlockPos;

public class NoGround extends Module {
    public static NoGround INSTANCE;

    public NoGround() {
        super("NoGround", Category.Exploit);
        setChinese("无地面暴击");
        INSTANCE = this;
    }

    private final EnumSetting<Spoof> spoofMode = add(new EnumSetting<>("SpoofMode", Spoof.Packet));
    private final SliderSetting spoofY = add(new SliderSetting("SpoofY", 0.2f, 0f, 1f, 0.001, () -> spoofMode.getValue() == Spoof.Packet));
    private final BooleanSetting moveStop = add(new BooleanSetting("MoveStop", false));
    private final BooleanSetting pauseMove = add(new BooleanSetting("PuaseOnMove", true, () -> !moveStop.getValue()));
    private final SliderSetting pauseT = add(new SliderSetting("PauseTimer", 500, 0, 10000));
    private final BooleanSetting closeByElytra = add(new BooleanSetting("DisableOnElytra", true));
    private final BooleanSetting onDeath = add(new BooleanSetting("DisableOnDeath", true));
    private final BooleanSetting placeOnHead = add(new BooleanSetting("PlaceAbove", false).setParent());
    public final BooleanSetting p = add(new BooleanSetting("PauseOnEat", true, placeOnHead::isOpen).setParent());
    public final BooleanSetting sameHand = add(new BooleanSetting("SameHand", true, () -> p.isOpen() && p.visibility.getAsBoolean()));
    public final BooleanSetting inventory = add(new BooleanSetting("InventorySwap", true, placeOnHead::isOpen));
    private final BooleanSetting rotate = add(new BooleanSetting("Rotate", true, placeOnHead::isOpen));

    private boolean crit;
    private boolean jump;
    private boolean pause;
    private boolean reset;
    private final Timer timer = new Timer();
    private final Timer pauseTimer = new Timer();

    @Override
    public void onEnable() {
        crit = false;
        jump = false;
        pause = false;
        reset = true;
        pauseTimer.setMs(pauseT.getValueInt());
        if (spoofMode.getValue() == Spoof.Jump && !jump) {
            if (pause) return;
            if (!pauseTimer.passedMs(pauseT.getValue())) return;
            spoofGround();
            jump = true;
        }
    }

    @EventHandler
    private void onDeath(DeathEvent death) {
        if (death.getPlayer() == mc.player && onDeath.getValue()) {
            disable();
            CommandManager.sendChatMessage("§4[NoGround] Player died, disabling module!");
        }
    }

    @EventHandler
    private void onTick(TickEvent event) {
        if (event.isPost()) return;
        if (nullCheck()) return;
        if (pauseMove.getValue() && playerMoved() && !moveStop.getValue()) {
            pause = true;
            jump = false;
            crit = false;
            reset = false;
        } else {
            pause = false;
            if (!reset) {
                reset = true;
                pauseTimer.reset();
            }
        }

        if (moveStop.getValue() && playerMoved() && crit) {
            CommandManager.sendChatMessage("§4[NoGround] Player moved, disabling module!");
            disable();
        } else if (playerUsingElytra() && closeByElytra.getValue() && mc.player.isFallFlying()) {
            CommandManager.sendChatMessage("§4[NoGround] Elytra flying, disabling module!");
            disable();
        } else if (placeOnHead.getValue() && BlockUtil.canPlace(mc.player.getBlockPos().add(0, 2, 0))) {
            if (pause) return;
            doPlace();
        }
    }

    @EventHandler
    private void onMove(MoveEvent event) {
        if (!nullCheck() && !jump && !pause && pauseTimer.passedMs(pauseT.getValue())) {
            if (spoofMode.is(Spoof.Packet)) {
                event.setY(spoofY.getValueFloat());
            } else {
                mc.player.jump();
            }
            //MovementUtil.setMotionY(spoofY.getValueFloat());
            jump = true;
        }
        if (!nullCheck() && mc.player.fallDistance > 0.0F && !mc.player.isOnGround() && !pause && pauseTimer.passedMs(pauseT.getValue())) {
            crit = true;
            //event.setX(0);
            event.setY(0);
            //MovementUtil.setMotionY(0);
            //event.setZ(0);
        }
    }

    private void spoofGround() {
        if (spoofMode.getValue() == Spoof.Jump) {
            mc.player.jump();
        }
    }

    private void doPlace() {
        if (p.getValue() && PauseUtil.checkPause(sameHand.getValue())) return;
        for (Entity entity : mc.world.getEntities()) {
            if (entity instanceof EndCrystalEntity && entity.getBlockPos().equals(mc.player.getBlockPos().add(0, 2, 0))) {
                mc.getNetworkHandler().sendPacket(PlayerInteractEntityC2SPacket.attack(entity, mc.player.isSneaking()));
                EntityUtil.swingHand(Hand.MAIN_HAND, AntiCheat.INSTANCE.swingMode.getValue());
                return;
            }
        }

        int oldSlot = mc.player.getInventory().selectedSlot;
        int itemResult = InventoryUtil.findItemInventorySlot(Items.OBSIDIAN);
        if (itemResult != -1) {
            doSwap(itemResult, oldSlot);
            BlockUtil.placeBlock(mc.player.getBlockPos().add(0, 2, 0), rotate.getValue());
            EntityUtil.swingHand(Hand.MAIN_HAND, AntiCheat.INSTANCE.swingMode.getValue());
            doSwap(itemResult, oldSlot);
        }
    }

    private boolean playerMoved() {
        //return mc.player.speed != 0;
        return (mc.options.backKey.isPressed() || mc.options.forwardKey.isPressed()
                || mc.options.leftKey.isPressed() || mc.options.rightKey.isPressed())
                && Freecam.INSTANCE.isOff();
    }

    private boolean playerUsingElytra() {
        return mc.player.isFallFlying() || (FakeFly.INSTANCE.isOn() && FakeFly.INSTANCE.fly);
    }

    public boolean canPlace(BlockPos pos) {
        return mc.world.getBlockState(pos.add(1, 0, 0)).isFullCube(mc.world, pos.add(1, 0, 0)) || mc.world.getBlockState(pos.add(-1, 0, 0)).isFullCube(mc.world, pos.add(-1, 0, 0)) || mc.world.getBlockState(pos.add(0, 0, 1)).isFullCube(mc.world, pos.add(0, 0, 1)) || mc.world.getBlockState(pos.add(0, 0, -1)).isFullCube(mc.world, pos.add(0, 0, -1)) || mc.world.getBlockState(pos.add(0, 1, 0)).isFullCube(mc.world, pos.add(0, 1, 0)) || mc.world.getBlockState(pos.add(0, -1, 0)).isFullCube(mc.world, pos.add(0, -1, 0));
    }

    public boolean paused() {
        return !timer.passedMs(100);
    }

    private void doSwap(int slot, int selectSlot) {
        if (inventory.getValue()) {
            InventoryUtil.inventorySwap(slot, selectSlot);
            EntityUtil.syncInventory();
        } else if (slot < 9) {
            InventoryUtil.switchToSlot(slot);
        }
    }

    private enum Spoof {
        Packet, Jump
    }
}