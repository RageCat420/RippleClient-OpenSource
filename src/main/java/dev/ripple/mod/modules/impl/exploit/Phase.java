package dev.ripple.mod.modules.impl.exploit;

import dev.ripple.Ripple;
import dev.ripple.api.events.eventbus.EventHandler;
import dev.ripple.api.events.impl.LookAtEvent;
import dev.ripple.api.events.impl.UpdateWalkingPlayerEvent;
import dev.ripple.api.utils.entity.EntityUtil;
import dev.ripple.api.utils.entity.InventoryUtil;
import dev.ripple.mod.modules.Module;
import dev.ripple.mod.modules.impl.client.AntiCheat;
import dev.ripple.mod.modules.impl.player.KeyPearl;
import dev.ripple.mod.modules.settings.impl.BooleanSetting;
import dev.ripple.mod.modules.settings.impl.SliderSetting;
import net.minecraft.block.Blocks;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityPose;
import net.minecraft.entity.decoration.GlowItemFrameEntity;
import net.minecraft.entity.decoration.ItemFrameEntity;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.PlayerInteractItemC2SPacket;
import net.minecraft.util.Hand;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;

public class Phase extends Module {
    public static Phase INSTANCE;

    public Phase() {
        super("Phase", Category.Exploit);
        setChinese("珍珠穿墙");
        INSTANCE = this;
    }

    public final BooleanSetting itemFrame = add(new BooleanSetting("BreakFrame", true));
    public final BooleanSetting scaffold = add(new BooleanSetting("BreakScaffolding", true));
    public final BooleanSetting autoYaw = add(new BooleanSetting("AutoYaw", true));
    private final BooleanSetting rotation = add(new BooleanSetting("Rotation", false).setParent());
    private final SliderSetting steps = add(new SliderSetting("Steps", 0.05, 0, 1, 0.01, rotation::isOpen));
    private final SliderSetting fov = add(new SliderSetting("Fov", 10, 0, 50, rotation::isOpen));
    private final SliderSetting priority = add(new SliderSetting("Priority", 100, 0, 100, rotation::isOpen));
    private final BooleanSetting sync = add(new BooleanSetting("Sync", true));
    public final SliderSetting pitch = add(new SliderSetting("Pitch", 80f, -90f, 90f));
    public final SliderSetting crawlP = add(new SliderSetting("CrawlPitch", -90f, -90f, 90f));
    public Vec3d directionVec = null;

    @EventHandler
    public void onRotate(LookAtEvent event) {
        if (directionVec != null) {
            event.setTarget(directionVec, steps.getValueFloat(), priority.getValueFloat());
        }
    }

    private boolean faceVector(Vec3d directionVec) {
        this.directionVec = directionVec;
        return Ripple.ROTATION.inFov(directionVec, fov.getValueFloat());
    }

    Vec3d targetPos;

    private float getPitch() {
        return mc.player.isInSwimmingPose() ? crawlP.getValueFloat() : pitch.getValueFloat();
    }

    private void updatePos() {
        targetPos = new Vec3d(mc.player.getX() + MathHelper.clamp(roundToClosest(mc.player.getX(), Math.floor(mc.player.getX()) + 0.241, Math.floor(mc.player.getX()) + 0.759) - mc.player.getX(), -0.2, 0.2), mc.player.getY() - 0.5, mc.player.getZ() + MathHelper.clamp(roundToClosest(mc.player.getZ(), Math.floor(mc.player.getZ()) + 0.241, Math.floor(mc.player.getZ()) + 0.759) - mc.player.getZ(), -0.2, 0.2));
    }

    @EventHandler
    public void onUpdateWalking(UpdateWalkingPlayerEvent event) {
        updatePos();
        if (!faceVector(targetPos)) {
            return;
        }
        sca();
        if (sync.getValue()) {
            attack();
            KeyPearl.INSTANCE.throwPearl(autoYaw.getValue() ? Ripple.ROTATION.getRotation(targetPos)[0] : mc.player.getYaw(), getPitch());
        } else {
            throwPearl(mc.player.getYaw(), mc.player.getPitch());
        }
        disable();
    }

    @Override
    public void onUpdate() {
        updatePos();
        if (!faceVector(targetPos)) {
            return;
        }
        sca();
        throwPearl(mc.player.getYaw(), mc.player.getPitch());
        disable();
    }

    public void throwPearl(float yaw, float pitch) {
        KeyPearl.throwing = true;
        attack();
        int pearl;
        if (mc.player.getMainHandStack().getItem() == Items.ENDER_PEARL) {
            sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id, yaw, pitch));
        } else if (KeyPearl.INSTANCE.inventory.getValue() && (pearl = InventoryUtil.findItemInventorySlot(Items.ENDER_PEARL)) != -1) {
            InventoryUtil.inventorySwap(pearl, mc.player.getInventory().selectedSlot);
            sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id, yaw, pitch));
            InventoryUtil.inventorySwap(pearl, mc.player.getInventory().selectedSlot);
            EntityUtil.syncInventory();
        } else if ((pearl = InventoryUtil.findItem(Items.ENDER_PEARL)) != -1) {
            int old = mc.player.getInventory().selectedSlot;
            InventoryUtil.switchToSlot(pearl);
            sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id, yaw, pitch));
            InventoryUtil.switchToSlot(old);
        }
        KeyPearl.throwing = false;
    }

    @Override
    public void onEnable() {
        directionVec = null;
        if (nullCheck()) {
            disable();
            return;
        }
        updatePos();
        if (rotation.getValue()) {
            return;
        }
        sca();
        if (sync.getValue()) {
            attack();
            KeyPearl.INSTANCE.throwPearl(autoYaw.getValue() ? Ripple.ROTATION.getRotation(targetPos)[0] : mc.player.getYaw(), getPitch());
        } else {
            throwPearl(mc.player.getYaw(), mc.player.getPitch());
        }
        disable();
    }

    public void attack() {
        if (itemFrame.getValue()) {
            for (Entity entity : mc.world.getEntities()) {
                if ((entity instanceof ItemFrameEntity || entity instanceof GlowItemFrameEntity) && entity.getBlockPos().equals(mc.player.getBlockPos())) {
                    Ripple.ROTATION.snapAt(entity.getPos());
                    mc.interactionManager.attackEntity(mc.player, entity);
                    mc.player.swingHand(Hand.MAIN_HAND);
                    if (AntiCheat.INSTANCE.snapBack.getValue()) Ripple.ROTATION.snapBack();
                }
            }
        }
    }

    public void sca() {
        if (scaffold.getValue() && !Ripple.BREAK.isMining(mc.player.getBlockPos())) {
            if (mc.world.getBlockState(mc.player.getBlockPos()).getBlock() == Blocks.SCAFFOLDING && mc.player.getPose() != EntityPose.SWIMMING) {
                mc.interactionManager.attackBlock(mc.player.getBlockPos(), Direction.UP);
                EntityUtil.swingHand(Hand.MAIN_HAND);
            }
        }
    }

    private double roundToClosest(double num, double low, double high) {
        double d1 = num - low;
        double d2 = high - num;

        if (d2 > d1) {
            return low;

        } else {
            return high;
        }
    }
}